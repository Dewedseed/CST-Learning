# Heap memory

堆内存解决方案

- 拷贝构造函数：堆内存复制效率低
- 移动语义：既保证效率、又保证安全
- 对象赋值控制：操作符重载
- 智能指针：不要使用裸指针，大部分操作编译优化完成，不增加开销

## Copy

- 拷贝构造函数/转换构造函数
  - 使用另一个对象初始化当前对象
  - 参数是当前类的对象引用
  - 当需要转存时需要拷贝构造
- 浅拷贝
  - 复制对象内存
- 深拷贝
  - 复制对象内存及对象成员指向的堆空间

## Move

- 移动语义
  - 没有移动语义时采用指针方法，存在内存安全和线程安全问题
  - 堆栈空间控制在类当中，外部无需申请堆空间，直接在栈空间中创建
- 引用
  - 左值：可取地址/占用空间、例如变量
  - 右值：不能取地址、例如字面量1、true、nullptr、this、枚举
    - 右值引用 `Type && var`
- 函数重载
  - move 函数：将普通对象强制转换为右值引用，只做类型转换、编译时完成，不占用资源
  - 当进行传参时，形参进行初始化，实参强制转换为右值引用，形参调用右值引用构造函数

## Assign

- 赋值控制
  - 不调用拷贝构造，但是本质上是内存拷贝操作
  - `obj1 = obj2` 不调用拷贝构造，调用操作符函数
  - `Class obj1 = obj2` 调用拷贝构造，不安全
- 操作符重载
  - 与构造函数不同在于，构造时对象默认为空，是初始化操作，赋值时不一定，需要先清空
  - 拷贝赋值 `Class& operator = (const Class& c);`
  - 移动赋值 `Class& operator = (Class&& c);`
- 注意
  - 自赋值 `c = c;` 由于 `c` 清空操作，会报错

## Auto Pointer

- 智能指针
  - 根据作用域自动申请和释放内存，用栈空间特性管理堆空间
  - 参数传递时可以将堆空间移动过去，减少复制
- 设计原则
  - 支持管理单个对象和对象数组
  - 自动构造存储堆对象指针、析构删除空间
  - 可移动构造、可移动赋值
  - 不可复制构造、不可复制赋值
- 实现原理
  - 栈区对象生命周期
    - 栈区 RAII 资源获取即初始化
    - 析构调用清理
  - 移动语义
    - 转移生命周期
- 标准库
  - `unique_ptr<Data> ptr(new Data);`
    - 需要 `new Data` 申请空间再调用智能指针管理
    - 如果申请了空间但是由于异常捕获退出，未进行管理，会产生野指针，指向空间无法释放
  - `auto ptr2 = make_unique<Data>();` C++14
    - 编译器生成更小更快代码
    - 减少重复类型设定
    - 内存安全，控制泄漏
  - 注意
    - 尽量不要释放控制权 (兼容旧系统)，需要手动释放
