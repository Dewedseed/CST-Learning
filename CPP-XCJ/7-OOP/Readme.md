# Object-Oriented Programming

## Paradigm

编程范式：面向对象、面向过程、函数式、解释式

**面向对象编程范式**

- 类 Class
  - 默认 private, 包含属性和方法
  - 结构体 Struct 默认 public，一些规范中要求只包含数据成员，不包含方法
  - 命名类型是名词
- 对象 Object
  - 实例化/数据实体，声明时分配内存
- 内存空间
  - 类对象占用内存大小等于成员变量之和
  - 无成员变量时会占用1字节
  - 函数不占用空间
  - 虚函数指针会占用空间
  - 编译优化内存对齐可能导致内存变大
- 静态
  - 静态成员变量
    - 多个对象只会存在一个变量
    - 不会随对象生成或销毁，需要特殊声明并定义
    - 遵守类成员访问规则：私有/保护/公开
  - 静态成员函数
    - 不关联任何对象
    - 无 this 指针
    - 函数地址存储在常规函数指针
    - 作用是访问类私有成员
  - 应用场景
    - 单例模式
    - 成员函数封装成普通函数
- 基本原则
  - S 单一职责原则 任务分割 日志输出/格式化
  - L 里氏替换原则 引用基类可以替换成任意子类
  - I 接口隔离原则 使用多个接口而非一个接口 不引用不需要的接口
  - O 开闭原则 扩展开放修改关闭 提高可扩展性
  - D 依赖倒置原则 依赖接口而非实现 避免互相引用
  - LoD 迪米特原则 与直接对象交互、间接对象隔离

## Syntax

- 类声明与作用域
- 类对象、对象指针、对象引用
- `this` 指针
- 内联函数 `inline`
  - 函数改变，所有相关文件需要重编译
  - 编译内联函数调用时，会将所有代码复制过去
  - 模板类型需要内联

## Constructor/Destructor

- 初始化
  - 默认成员初始化器
    - 声明时即初始化
    - C++11 引入
  - 初始化器列表
    - `Class() : prop1(val1), prop2{val2}, prop3(this->prop1) {}`
    - 优先级更高
    - 针对不同构造函数赋予不同值
  - 构造函数赋值
    - 增加开销，尽量减少使用
    - 不添加业务代码，避免出错
- 构造函数
  - 访问权限: 单例模式私有
  - 多个构造函数，默认隐式转换构造函数
  - 显式转换构造 `explicit`
  - 拷贝构造/移动构造
- 析构函数
  - 释放堆区内存
- 堆区对象创建
  - 申请空间 malloc => 转换地址格式为类指针 => 初始化成员 => 进入构造函数

## Inheritance

- **继承**
  - 特定场景下必须使用
  - 存在滥用情况，目前建议减少使用
  - 使用 `组合` 替代
- 内存分配
  - `[基类成员变量][子类成员变量]`
- `protected`
  - 规范要求所有成员变量都是保护类型
  - 子类无法访问基类私有成员
- 构造函数
  - 默认调用无参构造函数
  - `A():Base(100) {}` 选用不同基类构造函数
- 注意事项
  - 一般只用 public 继承，不建议多继承、保护继承、私有继承
- 场景
  - `is-a` 关系，即一个类型明显是另一个类型的具体类或特例
  - 多态性，通过虚函数定义接口或基类指针调用派生类函数
  - 代码复用
- 禁用
  - `has-a` 一个类是另一个类的组件，避免继承具体类，使用组合
  - 多继承破坏封装性

## Polymorphisms

- **多态**
  - 为不同数据类型的实体提供统一的接口
- 动态多态
  - 在运行时确定
  - **虚函数表**
- 静态多态
  - 在编译时确定
  - **函数重载**
  - **模板**
- 虚函数表
  - 不用虚函数时，当函数形参为基类、实参为子类时，会调用基类函数而非子类函数
  - `override` 会检查父类是否声明虚函数
  - 虚函数表在内存中保存函数指针
    - 基类 `Base::_vfptr -> Base::vftable[Base::F1(), Base::F2()]`
    - 子类 `A::_vfptr -> A::vftable[A::F1(), A::F2()]`

## Abstract Class

- 抽象类与纯虚函数
  - 基类存在纯虚函数时，无法实例化对象
  - 派生类如果不重写纯虚函数时，也无法实例化对象
  - 用途：强制用户重写函数
- 语法 `virtual 返回类型 函数名(参数) = 0;`
- 析构函数
  - 抽象类绝大多数情况下析构函数需要设置为虚函数
  - 在堆区生成对象 `Base* b = new BaseA();` 抽象类未设置虚析构函数时，派生类析构函数不会调用

## Composition & Delegation

- **组合/聚合** `has a`
  - 多个类对象组合成某个对象
  - 某个类中有其他类的对象，存于栈区
  - 架构上需要其他类的全部实现，拓展时组合代码需要修改
  - 替换继承
- **委托**
  - 指针的组合
  - 某个类中有其他类的指针，存于堆区
  - 架构上不需要知道其他类的实现，拓展时无需修改
